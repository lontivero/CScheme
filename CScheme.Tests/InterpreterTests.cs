namespace CScheme.Tests;

public class InterpreterTests
{
    [Theory]
    [InlineData("1", "1" , "numbers")]
    [InlineData("+1", "1" , "explicit positive numbers")]
    [InlineData("-1", "-1" , "negative numbers")]
    [InlineData("(*)", "1" , "multiplication")]
    [InlineData("(* 2)", "2" , "multiplication")]
    [InlineData("(* 2 3)", "6" , "multiplication")]
    [InlineData("(* 2 3 4)", "24" , "multiplication")]
    [InlineData("(/)", "1" , "division")]
    [InlineData("(/ 2)", "2" , "division")]
    [InlineData("(/ 9 2)", "4" , "division")]
    [InlineData("(/ 12 2 3)", "2" , "division")]
    [InlineData("(%)", "1" , "modulus")]
    [InlineData("(% 2)", "2" , "modulus")]
    [InlineData("(% 9 2)", "1" , "modulus")]
    [InlineData("(% 8 2)", "0" , "modulus")]
    [InlineData("(% 26 7 3)", "2" , "modulus")]
    [InlineData("(+)", "0" , "strange addition case")]
    [InlineData("(+ 10)", "10" , "explicit positive")]
    [InlineData("(+ 10 2)", "12" , "addition")]
    [InlineData("(+ 10 2 3)", "15" , "addition")]
    [InlineData("(-)", "0" , "strange subtraction case")]
    [InlineData("(- 10)", "-10" , "negation")]
    [InlineData("(- 10 2)", "8" , "subtraction")]
    [InlineData("(- 10 2 3)", "5" , "subtraction")]
    [InlineData("(if (* 0 1) 10 20)", "20" , "if")]
    [InlineData("(if (* 1 1) 10 20)", "10" , "if")]
    [InlineData("(if (* 1 1) 10 bomb)", "10" , "if (special form)")]
    [InlineData("(* 1234567890987654321 1234567890987654321)", "1524157877457704723228166437789971041" , "bigint math")]
    [InlineData("(let ((x 2)) x)", "2" , "simple let")]
    [InlineData("(let ((a 00) (b 10) (c 20)) (if a b c))", "20" , "conditional eval")]
    [InlineData("(let ((square (lambda (x) (* x x)))) (square 4))", "16" , "lambda")]
    [InlineData("(let ((square (lambda (x) (* x x)))) square)", "Function" , "print lambda")]
    [InlineData("(let ((times3 (let ((n 3)) (lambda (x) (* n x))))) (times3 4))", "12" , "closure")]
    [InlineData("(let ((times3 (let ((makemultiplier (lambda (n) (lambda (x) (* n x))))) (makemultiplier 3)))) (times3 5))", "15" , "higher order functions")]
    [InlineData("(letrec ((factorial (lambda (n) (if n (* n (factorial (- n 1))) 1)))) (factorial 4))", "24" , "letrec and recursion")]
    [InlineData("(let ((a 1) (b 2)) (let ((a b) (b a)) b))", "1" , "let binds in parallel (should work in earlier versions too)")]
    [InlineData("(let ((a 1) (b 2)) (let* ((a b) (b a)) b))", "2" , "let* binds sequentially")]
    [InlineData("(let ((a 5)) (let ((b (* a 2))) (let ((c (- b 3))) c)))", "7" , "poor-man's sequential expressions")]
    [InlineData("(let* ((a 5) (b (* a 2)) (c (- b 3))) c)", "7" , "let* sequential expressions")]
    [InlineData("(list 1 2 3)", "(1 2 3)" , "list")]
    [InlineData("(car (list 1 2 3))", "1" , "car")]
    [InlineData("(cdr (list 1 2 3))", "(2 3)" , "cdr")]
    [InlineData("(cat '(1 2) '(a b))", "(1 2 a b)" , "cat")]
    [InlineData("(cat '(1 2) '())", "(1 2)" , "cat")]
    [InlineData("(cat '() '(1 2))", "(1 2)" , "cat")]
    [InlineData("(cons 1 (list 2 3))", "(1 2 3)" , "cons")]
    [InlineData("(cons 1 (cons 2 (cons 3 nil)))", "(1 2 3)" , "cons x3")]
    [InlineData("(let ((a 1) (b 2) (c 3)) (list a b c))", "(1 2 3)" , "list")]
    [InlineData("(let ((a (list 1 2 3))) (car a))", "1" , "car")]
    [InlineData("(let ((a (list 1 2 3))) (cdr a))", "(2 3)" , "cdr")]
    [InlineData("(quote (* 2 3))", "(* 2 3)" , "quote primitive")]
    [InlineData("'(* 2 3)", "(* 2 3)" , "quote primitive with sugar")]
    [InlineData("(eval '(* 2 3))", "6" , "eval quoted expression")]
    [InlineData("(quote (* 2 (- 5 2)))", "(* 2 (- 5 2))" , "quote nested")]
    [InlineData("(quote (* 2 (unquote (- 5 2))))", "(* 2 3)" , "quote nested unquote")]
    [InlineData("'(* 2 ,(- 5 2))", "(* 2 3)" , "quote nested unquote with sugar")]
    [InlineData("(quote (quote 1 2 3))", "(quote 1 2 3)" , "quote special form")]
    [InlineData("(let ((or (macro (a b) '(if ,a 1 (if ,b 1 0))))) (or 1 BOOM))", "1" , "macro as special form")]
    [InlineData("(let ((and (macro (a b) '(if ,a (if ,b 1 0) 0)))) (and 0 BOOM))", "0" , "macro as special form")]
    [InlineData("(let ((a 1)) (begin (set! a 2) a))", "2" , "begin and assign")]
    [InlineData("(let* ((a 5) (dummy (set! a 10))) a)", "10" , "re-assign after let")]
    [InlineData("(begin (define fac (lambda (x) (if x (* x (fac (- x 1))) 1))) (fac 7))", "5040" , "define recursive")]
    [InlineData("(begin (define square (lambda (x) (* x x))) (square 4))", "16" , "global def")]
    [InlineData("(let ((x 4)) (begin (define y 8) (* x y))))", "32" , "local def")]
    [InlineData("(and 0 0)", "0" , "or (false)")]
    [InlineData("(and 1 0)", "0" , "or (false)")]
    [InlineData("(and 0 1)", "0" , "or (false)")]
    [InlineData("(and 1 1)", "1" , "or (true)")]
    [InlineData("(or 0 0)", "0" , "or (false)")]
    [InlineData("(or 1 0)", "1" , "or (true)")]
    [InlineData("(or 0 1)", "1" , "or (true)")]
    [InlineData("(or 1 1)", "1" , "or (true)")]
    [InlineData("(not? 0)", "1" , "or (true)")]
    [InlineData("(not? 1)", "0" , "or (false)")]
    [InlineData("(xor 0 0)", "0" , "xor (false)")]
    [InlineData("(xor 1 0)", "1" , "xor (true)")]
    [InlineData("(xor 0 1)", "1" , "xor (true)")]
    [InlineData("(xor 1 1)", "0" , "xor (false)")]
    [InlineData("(let ((square (lambda (x) (* x x)))) (map square '(1 2 3 4 5 6 7 8 9)))", "(1 4 9 16 25 36 49 64 81)" , "mapping")]
    [InlineData("(let ((square (lambda (x) (* x x)))) (map square '(9)))", "(81)" , "mapping single")]
    [InlineData("(let ((square (lambda (x) (* x x)))) (map square '()))", "()" , "mapping empty")]
    [InlineData("(fold * 1 '(2 3 4 5))", "120" , "fold")]
    [InlineData("(reverse '(1 2 3))", "(3 2 1)" , "reverse")]
    [InlineData("(call/cc (lambda (c) (c 10)))", "10" , "super-simple call/cc")]
    [InlineData("(call/cc (lambda (c) (if (c 10) 20 30)))", "10" , "call/cc bailing out of 'if'")]
    [InlineData("(+ 8 (call/cc (lambda (k^) (* (k^ 5) 100))))", "13" , "call/cc bailing out of multiplication")]
    [InlineData("(* (+ (call/cc (lambda (k^) (/ (k^ 5) 4))) 8) 3)", "39" , "call/cc nesting")]
    public void SimplestTests(string program, string expectedResult, string comment)
    {
        var (parsingResult, _) = Interpreter.Parse([], Tokenizer.Tokenize(program).ToArray());
        var result = Interpreter.Eval(Interpreter.Env, parsingResult[0]); 
        Assert.Equal(expectedResult, Interpreter.Print(result.Expression));
    }
    
    [Theory]
    [InlineData("(+)", "0" , "strange addition case")]
    [InlineData("(+ 10)", "10" , "explicit positive")]
    [InlineData("(+ 10 2)", "12" , "addition")]
    [InlineData("(+ 10 2 3)", "15" , "addition")]
    public void XSimplestTests(string program, string expectedResult, string comment)
    {
        var (parsingResult, _) = Interpreter.Parse([], Tokenizer.Tokenize(program).ToArray());
        var result = Interpreter.Eval(Interpreter.Env, parsingResult[0]); 
        Assert.Equal(expectedResult, Interpreter.Print(result.Expression));
    }
}